#!/usr/bin/perl -w
use strict;

# make module lattice files

# FIX: why aren't we using YAML as the configuration language?

# lattice file for doing module-access analysis
#
# we do a product of N ref-level taint analysis:
#    $foo_otherAccess [level = ref, sign = neg]
#    $foo_alloc       [level = ref, sign = pos]
#    $foo_otherAccess < $foo_alloc

# lattice file for doing module-write analysis
#
# we do a product of N ref-level taint analysis:
#    $foo_otherWrite [level = ref, sign = neg]
#    $foo_alloc      [level = ref, sign = pos]
#    $foo_otherWrite < $foo_alloc

# lattice file for doing module-trust analysis
#
# we do a product of N hybrid value/ref-level taint analysis:
#    $foo_access       [level = ref,   sign = neg]
#    $foo_otherControl [level = value, sign = pos]
#    $foo_access < $foo_otherControl

# here is the standard taint analysis for reference:
#    $untainted [level = value, sign = neg]
#    $tainted   [level = value, sign = pos]
#    $untainted < $tainted

# globals
my $access;                     # do an access analysis?
my $write;                      # do a write analysis?
my $trust;                      # do a trust analysis?
my @modules;                    # list of modules
my @mod_files;                  # list of .mod files

sub parse_command_line {
  while (@ARGV) {
    my $arg = shift @ARGV;
    if (0) {                    # orthogonality
    } elsif ($arg eq '--access') {
      ++$access;
    } elsif ($arg eq '--write') {
      ++$write;
    } elsif ($arg eq '--trust') {
      ++$trust;
    } elsif ($arg eq '--modules') {
      $arg = shift @ARGV;
      my @modules0 = split ' ', $arg;
      push @modules, @modules0;
    } elsif ($arg eq '--mod-file') {
      $arg = shift @ARGV;
      push @mod_files, $arg;
    } else {
      die "illegal argument:$arg\n";
    }
  }
}

sub check_integrity {
  # access and write mutually exclude
  if ($access && $write) {
    die "Do not specify both --access and --write\n";
  }
}

sub load_mod_files {
  my $current_module;
  for my $mod_file (@mod_files) {
    open FILE, $mod_file;
    while (<FILE>) {
      # clean up line
      my $line = $_;
      chomp $line;              # delete trailing newline
      $line =~ s/#.*$//;        # delete hash comments
      $line =~ s/^\s*//;        # delete leading whitespace
      $line =~ s/\s*$//;        # delete trailing whitespace
      next if $line =~ /^.\s*$/; # skip blank lines
      # is it a keyword line?
      if ($line =~ /^\*\s*(\S+)\s*:\s*(\S+)$/) {
        my $keyword = $1;
        my $value = $2;
        if ($keyword eq 'module') {
          $current_module = $value;
          push @modules, $value;
        } else {
          die "$mod_file:$.: illegal keyword '${keyword}'\n";
        }
      } else {
        # it is a plain line; we don't need it
      }
    }
    close FILE;
  }
}

sub be_verbose {
  if ($access) {
    warn "module_make_lattice generating lattice for Access analysis\n";
  }
  if ($write) {
    warn "module_make_lattice generating lattice for Write analysis\n";
  }
  if ($trust) {
    warn "module_make_lattice generating lattice for Trust analysis\n";
  }
  warn "module_make_lattice modules: " . join(', ', @modules) . "\n";
}

sub emit_lattice {
  for my $mod (@modules) {
    if ($access) {
      # module-access
      print "partial order [casts-preserve] {\n";
      # $untainted
      print "  \$${mod}_otherAccess [level = ref, sign = neg]\n";
      # $tainted
      print "  \$${mod}_alloc       [level = ref, sign = pos]\n";
      # $untainted < $tainted
      print "  \$${mod}_otherAccess < \$${mod}_alloc\n";
      print "}\n";
    } elsif ($write) {
      # module-write
      print "partial order [casts-preserve] {\n";
      # $untainted
      print "  \$${mod}_otherWrite [level = ref, sign = neg]\n";
      # $tainted
      print "  \$${mod}_alloc      [level = ref, sign = pos]\n";
      # $untainted < $tainted
      print "  \$${mod}_otherWrite < \$${mod}_alloc\n";
      print "}\n";
    }

    if ($trust) {
      # module-trust
      print "partial order [casts-preserve] {\n";
      # $untainted
      print "  \$${mod}_access       [level = ref,   sign = neg]\n";
      # $tainted
      print "  \$${mod}_otherControl [level = value, sign = pos]\n";
      # $untainted < $tainted
      print "  \$${mod}_access < \$${mod}_otherControl\n";
      print "}\n";
    }
  }
}

# main
parse_command_line();
check_integrity();
load_mod_files();
be_verbose();
emit_lattice();
